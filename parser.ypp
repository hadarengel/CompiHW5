%{
    /* Prologue */
    #include <stdio.h>
    #include "hw5_output.hpp"
    #include "llvm_compiler.hpp"
    #include "parser.tab.hpp"

    extern int yylineno;
    extern int yylex();
    int yyerror(const char* message);
    Llvm_compiler comp;

    using namespace output;


%}

    /* Declerations Section */
 



    %token    B BOOL VOID INT BYTE STRING CONST TRUE FALSE IF RETURN WHILE BREAK CONTINUE SC COMMA NUM ID

    %right ASSIGN    

    %left OR
    %left AND
    %left EQUALOP
    %nonassoc RELOP 
    %left ADD,SUB
    %left MULT,DIV
	%right NOT IF
    %left LPAREN RPAREN LBRACE RBRACE
    %nonassoc ELSE


%%
    /* Grammer Rules Section */ 

    Program:  Funcs 
    ; 

    Funcs: /* empty */ {} 
    | FuncDecl Funcs {}
    ;

    FuncDecl: RetType ID LPAREN {openScope(false);} Formals RPAREN {addFunc($2.name, $1.type, $5.params_types);} LBRACE Statements RBRACE {closeScope();}
    ;

    RetType: Type {$$.type = $1.type;} 
    | VOID {$$.type = "VOID";}
    ;

    Formals: /* empty */ {$$.params_types = vector<std::string>();}
    | FormalsList {$$.params_types = $1.params_types;}
    ;

    FormalsList: FormalDecl {$$.params_types.push_back($1.type);}
    | FormalDecl COMMA FormalsList 
        {
        $$.params_types.push_back($1.type);
        mergeVectors($$.params_types, $3.params_types);
        }
    ;

    FormalDecl: TypeAnnotation Type ID 
        {
        addArg($3.name,$2.type, $1.is_const);
        $$.type = $2.type;
        }
    ;

    Statements: Statement {}
    | Statements Statement {}
    ;

    Statement: LBRACE {openScope(false);} Statements RBRACE {closeScope();}
    | TypeAnnotation Type ID SC 
        {
        if($1.is_const) output::errorConstDef(yylineno);
        addVar($3.name, $2.type, $1.is_const);
        }
    | TypeAnnotation Type ID ASSIGN Exp SC  
        {
        checkValidAssign($2.type, $5.type);
        addVar($3.name, $2.type, $1.is_const);
        }
    | ID ASSIGN Exp SC  
        {
        if(checkValidVar($1.name)) {
            output::errorConstMismatch(yylineno);
            abortParser(1);}
        checkValidAssign(typeOfSymbol($1.name),$3.type);
        }
    | Call SC {}
    | RETURN SC {checkRetType("VOID");}
    | RETURN Exp SC {checkRetType($2.type);}
    | IF  LPAREN MIfExp RPAREN  MIfStatement 
    | IF  LPAREN MIfExp RPAREN  MIfStatement ELSE {openScope(false);} Statement {closeScope();}
    | WHILE LPAREN Exp RPAREN {checkBoolType($3.type); openScope(true);} Statement {closeScope();}
    | BREAK SC {checkUnexpected("BREAK");}
    | CONTINUE SC {checkUnexpected("CONTINUE");}
    ;

    MIfExp: Exp {checkBoolType($1.type); openScope(false); }

    MIfStatement: Statement {closeScope();}

    Call: ID LPAREN ExpList RPAREN {$$.type = checkFuncDecl($1.name, $3.params_types);}
    | ID LPAREN RPAREN {$$.type = checkFuncDecl($1.name, vector<std::string>());}
    ;

    ExpList: Exp {$$.params_types.push_back($1.type);}
    | Exp COMMA ExpList 
        {
        $$.params_types.push_back($1.type);
        mergeVectors($$.params_types,$3.params_types);
        }
    ;

    Type: INT {$$.type="INT";}
    | BYTE {$$.type="BYTE";}
    | BOOL {$$.type="BOOL";}
    ;

    TypeAnnotation: /* empty */ {$$.is_const = false;}
    | CONST {$$.is_const = true;}
    ; 

    Exp: LPAREN Exp RPAREN {$$ = $2;}
    | Exp ADD Exp  
        {
        $$.type = comp.handle_add($1,$3);
        }
    | Exp SUB Exp  
        {
        $$.type = comp.handle_sub($1,$3);
        }
    | Exp MULT Exp  
        {
        $$.type = comp.handle_mul($1,$3);
        }
    | Exp DIV Exp  
        {
        $$.type = comp.handle_div($1,$3);
        }
    | ID
        {
        $$ = comp.handle_var($1.data);
        }
    | Call {$$ = $1;}
    | NUM {$$ = comp.handle_literal($1.data,"INT")}
    | NUM B {$$ = comp.handle_literal($1.data,"BYTE")}
    | STRING {$$ = comp.handle_string($1.data);}
    | TRUE {$$.data = "1"; $$.type = "BOOL"; $$.is_literal = true;}
    | FALSE {$$.data = "0"; $$.type = "BOOL"; $$.is_literal = true;}
    | NOT Exp   
        {
        $$.type = comp.handle_not($2);
        }
    | Exp AND {$$.label = comp.add_br_and_label($1);} Exp {$$ = comp.handle_and($1,$$.label,$4);}   
    | Exp OR {$$.label = comp.add_br_and_label($1);} Exp {$$ = comp.handle_or($1,$$.label,$4);}
    | Exp RELOP Exp 
        {
        $$ = comp.handle_relop_equalop($1,$2.data,$3);
        }
    | Exp EQUALOP Exp   
        {
        $$ = comp.handle_relop_equalop($1,$2.data,$3);
        }
    | LPAREN Type RPAREN Exp 
        {
        $$ = comp.handle_cast($1.type,$4)
        } 



    
%%
    /* Epilogue Section */    

    int main()
    {
        InitParser();
        int parse_ret = yyparse();
        FinishParser();
        return parse_ret;
    }

    int yyerror(const char* message){
        output::errorSyn(yylineno);
        exit(0);
    }
    